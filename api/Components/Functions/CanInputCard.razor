@using domain.Devices.dingoPdm.Functions
@using domain.Devices.dingoPdm.Enums

<MudCard Elevation="2">
    <MudCardHeader>
        <CardHeaderContent>
            <MudText Typo="Typo.h6">@Item.Number - @Item.Name</MudText>
        </CardHeaderContent>
        <CardHeaderActions>
            <MudIconButton Icon="@Icons.Material.Filled.Edit"
                           Size = "Size.Small"
                           OnClick="@OpenDialog"/>
        </CardHeaderActions>
    </MudCardHeader>
    <MudStack>
        <MudItem xs="3">
            <MudText Typo="Typo.body2" Color="Color.Secondary">Value</MudText>
            <MudText Typo="Typo.body1">@Item.Value</MudText>
        </MudItem>
        <MudItem xs="3">
            <MudText Typo="Typo.body2" Color="Color.Secondary">State</MudText>
            <MudText Typo="Typo.body1">@Item.Output</MudText>
        </MudItem>
    </MudStack>
</MudCard>

@code {
    [Parameter, EditorRequired]
    public CanInput Item { get; set; } = null!;

    [Parameter, EditorRequired]
    public Guid DeviceId { get; set; }

    [Inject] private IDialogService DialogService { get; set; } = null!;

    private async Task OpenDialog()
    {
        var parameters = new DialogParameters<CanInputDialog>
        {
            { x => x.Model, Item },
            { x => x.DeviceId, DeviceId }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<CanInputDialog>(
            $"CAN Input {Item.Number}",
            parameters,
            options);

        var result = await dialog.Result;

        if (!result.Canceled)
        {
            StateHasChanged();
        }
    }
}