@using domain.Devices.dingoPdm
@using application.Services
@using application.Models
@using Microsoft.JSInterop
@using Plotly.Blazor
@using Plotly.Blazor.Traces
@using Plotly.Blazor.Traces.ScatterLib
@using Plotly.Blazor.LayoutLib
@typeparam TDevice where TDevice : PdmDevice
@inject DevicePlotService PlotService
@implements IDisposable

<div style="overflow-y: auto; height: calc(100vh - 250px); padding: 24px; scrollbar-width: auto; scrollbar-color: #888 transparent;">

    <!-- Controls Section -->
    <MudPaper Class="pa-4 mb-4">
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
            <!-- Recording Controls -->
            <MudButton Color="Color.Success"
                       Variant="Variant.Outlined"
                       StartIcon="@Icons.Material.Filled.FiberManualRecord"
                       OnClick="StartRecording"
                       Disabled="@(_recordingState == RecordingState.Recording)">
                Record
            </MudButton>
            <MudButton Color="Color.Warning"
                       Variant="Variant.Outlined"
                       StartIcon="@Icons.Material.Filled.Pause"
                       OnClick="PauseRecording"
                       Disabled="@(_recordingState != RecordingState.Recording)">
                Pause
            </MudButton>
            <MudButton Color="Color.Error"
                       Variant="Variant.Outlined"
                       StartIcon="@Icons.Material.Filled.Stop"
                       OnClick="StopRecording"
                       Disabled="@(_recordingState == RecordingState.Stopped)">
                Stop
            </MudButton>

            <MudDivider Vertical="true" FlexItem="true" />

            <!-- Signal Selection -->
            <MudSelect T="IPlotReference"
                       @bind-Value="_selectedProp"
                       Label="Properties"
                       Variant="Variant.Outlined"
                       Dense="true"
                       Style="min-width: 150px">
                @foreach (var prop in _availableProps)
                {
                    <MudSelectItem Value="prop">@prop.Name</MudSelectItem>
                }
            </MudSelect>

            <MudButton Color="Color.Primary"
                       Variant="Variant.Outlined"
                       StartIcon="@Icons.Material.Filled.Add"
                       OnClick="AddSignal">
                Add Signal
            </MudButton>
        </MudStack>
    </MudPaper>

    <!-- Active Signals -->
    @if (_activeSignals.Any())
    {
        <MudPaper Class="pa-4 mb-4">
            <MudText Typo="Typo.h6" Class="mb-2">Active Signals</MudText>
            <MudChipSet T="IPlotReference">
                @foreach (var reference in _activeSignals)
                {
                    var color = PlotService.GetSignalColor(Device.Guid, reference);
                    <MudChip Text="@reference.Name"
                             Color="Color.Primary"
                             Style="@($"background-color: {color}; color: white;")"
                             OnClose="@CreateRemoveCallback(reference)" />
                }
            </MudChipSet>
        </MudPaper>
    }

    <!-- Chart Section -->
    @if (_activeSignals.Any())
    {
        <MudPaper Class="pa-4">
            <PlotlyChart @bind-Config="_config"
                         @bind-Layout="_layout"
                         @bind-Data="_data"
                         @ref="_chart"
                         Style="height: 500px; width: 100%;" />
        </MudPaper>
    }
    else
    {
        <MudPaper Class="pa-4">
            <MudText Typo="Typo.body1" Align="Align.Center" Color="Color.Secondary">
                Add signals above to start plotting. Click Record to begin data collection.
            </MudText>
        </MudPaper>
    }
</div>

@code {
    [Parameter, EditorRequired] public TDevice Device { get; set; } = null!;
    
    private PlotlyChart? _chart;
    private Config _config = new Config();
    private Layout _layout = new Layout();
    private IList<ITrace> _data = new List<ITrace>();
    private Timer? _refreshTimer;

    private RecordingState _recordingState = RecordingState.Stopped;
    private List<IPlotReference> _availableProps = [];
    private List<IPlotReference> _activeSignals = [];

    // Selection state
    private IPlotReference? _selectedProp;

    // Track data point counts per trace to use ExtendTrace
    private Dictionary<string, int> _traceSampleCounts = new();

    protected override void OnInitialized()
    {
        // Get MudBlazor default theme for styling
        var theme = new MudTheme();
        var palette = theme.PaletteDark;

        // Configure Plotly layout
        _layout.Title = new Title { Text = $"{Device.Name} Plot" };
        _layout.XAxis = new List<XAxis>
        {
            new XAxis { Title = new Plotly.Blazor.LayoutLib.XAxisLib.Title { Text = "Time" } }
        };
        _layout.YAxis = new List<YAxis>
        {
            new YAxis
            {
                Title = new Plotly.Blazor.LayoutLib.YAxisLib.Title { Text = "Value" },
                AutoRange = Plotly.Blazor.LayoutLib.YAxisLib.AutoRangeEnum.True
            }
        };

        _layout.PaperBgColor = palette.Surface.ToString();
        _layout.PlotBgColor = palette.Surface.ToString();
        _layout.Font = new Font
        {
            Color = palette.TextPrimary.ToString()
        };

        // Load existing active signals and recording state
        _availableProps = PlotService.GetAvailableProps(Device.Guid);
        _activeSignals = PlotService.GetActiveSignals(Device.Guid);
        _recordingState = PlotService.GetRecordingState(Device.Guid);

        // Initialize traces for existing signals
        foreach (var signal in _activeSignals)
        {
            AddTraceForSignal(signal, initialLoad: true);
        }

        // Start 20 Hz UI refresh timer
        _refreshTimer = new Timer(_ =>
        {
            InvokeAsync(() =>
            {
                RefreshChart();
                StateHasChanged();
            });
        }, null, TimeSpan.FromMilliseconds(50), TimeSpan.FromMilliseconds(50));
    }

    private async void RefreshChart()
    {
        if (_chart == null || !_activeSignals.Any() || !_data.Any())
            return;

        // Update recording state
        _recordingState = PlotService.GetRecordingState(Device.Guid);

        // Only update chart during recording
        if (_recordingState != RecordingState.Recording)
            return;

        // Update each trace with new data
        for (var i = 0; i < _activeSignals.Count && i < _data.Count; i++)
        {
            var reference = _activeSignals[i];
            var plotData = PlotService.GetPlotData(Device.Guid, reference);

            // Get new data points since last update
            var previousCount = _traceSampleCounts.GetValueOrDefault(reference.Name, 0);
            var newPoints = plotData.Skip(previousCount).ToList();

            if (!newPoints.Any()) continue;

            try
            {
                // Prepare X and Y data
                var xData = newPoints.Select(p => (object)p.Timestamp.ToString("HH:mm:ss.fff")).ToList();
                var yData = newPoints.Select(p => (object)p.Value).ToList();

                // Extend trace with new data
                await _chart.ExtendTrace(xData, yData, i);

                // Update sample count
                _traceSampleCounts[reference.Name] = plotData.Count;
            }
            catch (JSException ex)
            {
                // Log the exception to understand what's happening
                Console.WriteLine($"ExtendTrace failed for trace {i}: {ex.Message}");
            }
        }
    }

    private void StartRecording()
    {
        PlotService.StartRecording(Device.Guid);
        _recordingState = RecordingState.Recording;

        // Re-initialize traces if they were cleared (e.g., after Stop)
        if (!_data.Any() && _activeSignals.Any())
        {
            foreach (var signal in _activeSignals)
            {
                // Use initialLoad: true to include any existing data
                AddTraceForSignal(signal, initialLoad: true);
            }
        }
    }

    private void PauseRecording()
    {
        PlotService.PauseRecording(Device.Guid);
        _recordingState = RecordingState.Paused;
    }

    private void StopRecording()
    {
        PlotService.StopRecording(Device.Guid);
        _recordingState = RecordingState.Stopped;

        // Clear chart data and traces
        _data.Clear();
        _traceSampleCounts.Clear();
    }

    private void AddSignal()
    {
        if (_selectedProp == null) return;

        PlotService.AddSignal(Device.Guid, _selectedProp);
        _activeSignals = PlotService.GetActiveSignals(Device.Guid);

        // Add trace to chart - use initialLoad: true to include existing data
        // This ensures Plotly can extend the trace (empty traces can't be extended)
        AddTraceForSignal(_selectedProp, initialLoad: true);

        // Force re-render to ensure Plotly receives the new trace
        StateHasChanged();
    }

    private void RemoveSignal(IPlotReference reference)
    {
        // Get trace index BEFORE removing from service (while it's still in _activeSignals)
        var traceIndex = _activeSignals.IndexOf(reference);

        // Remove from service
        PlotService.RemoveSignal(Device.Guid, reference);
        _activeSignals = PlotService.GetActiveSignals(Device.Guid);

        // Remove trace from chart using the index we got earlier
        if (traceIndex >= 0 && traceIndex < _data.Count)
        {
            _data.RemoveAt(traceIndex);
        }

        _traceSampleCounts.Remove(reference.Name);
    }

    private EventCallback<MudChip<IPlotReference>> CreateRemoveCallback(IPlotReference reference)
    {
        return EventCallback.Factory.Create<MudChip<IPlotReference>>(this, _ => RemoveSignal(reference));
    }

    private void AddTraceForSignal(IPlotReference reference, bool initialLoad)
    {
        var color = PlotService.GetSignalColor(Device.Guid, reference) ?? "#2196F3";

        var plotData = PlotService.GetPlotData(Device.Guid, reference);

        var scatter = new Scatter
        {
            Name = reference.Name,
            Mode = ModeFlag.Lines,
            X = initialLoad ? plotData.Select(p => (object)p.Timestamp.ToString("HH:mm:ss.fff")).ToList() : new List<object>(),
            Y = initialLoad ? plotData.Select(p => (object)p.Value).ToList() : new List<object>(),
            Line = new Line { Color = color }
        };

        _data.Add(scatter);
        _traceSampleCounts[reference.Name] = plotData.Count;
    }

    public void Dispose()
    {
        _refreshTimer?.Dispose();
    }
}